
# 헥사고날 + 도메인 서비스 아키텍처 (중립 가이드)

> 특정 프로젝트나 코드베이스에 얽매이지 않고, **헥사고날 아키텍처**와 **도메인 서비스** 개념을 결합한 일반적 설계 가이드입니다.  
> UI 에디터, 다이어그램 툴, 로우코드/노코드 플랫폼 등 복잡한 인터랙티브 애플리케이션에 적용 가능하며, **View ↔ Controller ↔ Engine(파사드) ↔ Store** 흐름을 전제로 합니다.

---

## 1) 목적과 범위

- **중립적 기준** 제공: 다양한 팀이 헥사고날 아키텍처를 도입할 때 참조할 수 있는 설계 기준.  
- **역할/경계/계약 정의**: UI, 애플리케이션 로직, 도메인 로직을 명확히 분리.  
- **평가 도구**: 장단점 및 트레이드오프를 판단할 수 있도록 객관적 기준 제공.

### 적합한 사례
- 페이지 빌더, 디자인 툴, 다이어그램 에디터, 노코드/로우코드 편집기.  
- 페이지, 레이어/노드, 액션/플로우, 정책/가시성, 바인딩, 히스토리 등 다중 도메인 관리.  
- **테스트 용이성**, **확장성**, **병렬 개발**이 필요한 경우.

---

## 2) 아키텍처 개요

### 2.1 상위 레이어 (헥사고날)
```
[UI / View]  ←→  [Controller (애플리케이션 계층)]  ←→  [Engine (파사드)]
                                               ↑
                                   [포트 / 어댑터 (인바운드/아웃바운드)]
                                               ↓
                                    [도메인 서비스 / 엔티티]
                                               ↓
                                 [스토어 / 퍼시스턴스 / I/O]
```

- **View (UI)**: 상태를 렌더링하고 사용자 이벤트를 위임. 로직 없음.  
- **Controller**: 유스케이스 조율. **Reader/Writer** 인터페이스 제공.  
- **Engine (파사드)**: 상태와 도메인 오퍼레이션의 단일 진입점. 스토어를 감싸고 외부에 노출하지 않음.  
- **포트/어댑터**: 외부 세계와의 계약 (정책, 원격 API, 플러그인 등).  
- **도메인 서비스**: 순수한 도메인 규칙과 로직 (바인딩, 정책, 검증, 히스토리 등).  
- **스토어**: 실제 상태 저장 구현. Engine 뒤에 감춤.

### 2.2 데이터 흐름
1. View → Controller.Writer 호출 (사용자 의도 전달).  
2. Writer → Engine 호출 (검증 후 상태 변경).  
3. Engine → Store 반영 후 구독자 알림.  
4. View → Controller.Reader를 통해 변경된 상태를 재구독 및 렌더.  

### 2.3 헥사고날 도입 이유
- 경계를 안정적으로 유지 → 도메인과 인프라 독립성.  
- 포트/어댑터 → *무엇*과 *어떻게*를 분리. 교체 가능.  

---

## 3) 핵심 구성 요소

### 3.1 Controller (Reader/Writer)
- **Reader**: 읽기 전용 쿼리와 **구독 훅** 제공.  
- **Writer**: 검증된 쓰기 동작 제공.  
- **네이밍 규칙**:  
  - Reader → `get*`, `use*`, `is*`, `*Token`  
  - Writer → `set*`, `append*`, `update*`, `remove*`, `toggle*`, `move*`, `run*`  
- **Facade Controller**: 여러 컨트롤러를 합쳐 View에 단일 진입점 제공.  

### 3.2 Engine (파사드)
- **책임**: 상태/도메인 연산의 단일 창구, 버전 관리, 구독 관리.  
- **예시 API**:  
  - `getState()`, `update(mutator)`, `subscribe(listener)`, `getVersionToken()`  
  - `pages.getAll()`, `nodes.getNodeById()`, `actions.run()`, `policy.evaluate()` 등 도메인 모듈.  

### 3.3 도메인 서비스
- **바인딩 서비스**: 표현식 평가, 바인딩 적용.  
- **정책/가시성 서비스**: 룰 기반 가시성 판별.  
- **검증 서비스**: 유효성 검사, 다이어그노스틱.  
- **히스토리/Undo 서비스**: 커맨드 기록과 되돌리기.  
- **데이터 스키마 서비스**: 버전 간 마이그레이션, 기본값 관리.  

### 3.4 포트/어댑터
- 인바운드 포트: Controller, Engine 인터페이스.  
- 아웃바운드 포트: 원격 API, 퍼시스턴스, 플러그인, 로깅.  

### 3.5 스토어
- 교체 가능: Redux, Zustand, CRDT, DB 등.  
- 외부에 직접 노출 금지, Engine이 감싸서 제공.

---

## 4) 상호작용 패턴

- **세밀 구독**: Reader는 특정 노드/속성 단위로 구독.  
- **검증/가드**: Writer에서 도메인 검증 수행. View는 단순 UI만.  
- **트랜잭션/Undo**: Engine에서 원자적 업데이트, History에 기록.  
- **플러그인/확장**: 기능/정책/액션 등록을 포트로 제공.  

---

## 5) 확장성 & 유연성

- 새 기능 = 새 Controller/Service 추가.  
- 인프라 교체 = 어댑터 교체.  
- 플러그인 = 등록 포트를 통해 컴포넌트/정책 추가.  
- 교차 기능(로깅/통계) = 아웃바운드 어댑터로 통합.  

---

## 6) 장단점

### 장점
- 관심사 분리 → UI와 도메인 독립.  
- 테스트 용이 → Controller/Service 단위 모킹 가능.  
- 확장 용이 → 새로운 기능을 도메인 단위로 추가.  
- 병렬 개발에 적합.  

### 단점
- 초기 비용(보일러플레이트, 인터페이스 설계).  
- 팀 전체 합의 필요(규칙 위반 시 무너짐).  
- 잘못된 구독 설계 → 성능 저하 위험.  
- 파사드 비대화 위험 → 도메인 모듈 분리 필요.  

---

## 7) 점검 체크리스트

- [ ] Engine이 Store를 완전히 감쌈.  
- [ ] Controller가 Engine만 의존.  
- [ ] View는 Controller만 의존.  
- [ ] Reader는 세밀한 구독 제공.  
- [ ] Writer는 검증/권한 처리.  
- [ ] 도메인 서비스는 포트로 연결, 교체 가능.  
- [ ] 타입 단일화(도메인 타입은 한 곳에서 정의).  

---

## 8) 마이그레이션 전략

- **스트랭글러 피그 패턴**: 기존 Store 감싸기 → 도메인별 점진 교체.  
- **빅뱅 교체**: 위험하지만 빠름. 전체 테스트 필요.  
- **하이브리드**: 변경이 잦은 도메인부터 단계적 교체.  

규칙:  
1. UI/UX는 변하지 않아야 함.  
2. 읽기 경로(Reader) → 쓰기 경로(Writer) 순으로 교체.  
3. Store 직접 접근 제거는 빠를수록 좋음.  

---

## 9) 최소 인터페이스 예시

```ts
interface Engine {
  getState(): Readonly<State>;
  update(mutator: (draft: State) => void): void;
  subscribe(cb: () => void): () => void;
  getVersionToken(): string;
  pages: PagesAPI;
  nodes: NodesAPI;
  actions: ActionsAPI;
  policy: PolicyAPI;
  binding: BindingAPI;
  ui: UIAPI;
}

interface Reader<T> {}
interface Writer<T> {}
interface Controller<R, W> {
  reader(): R;
  writer(): W;
}
```

---

## 10) 요약

- **View는 단순**: 로직 없음, Controller만 사용.  
- **Controller는 조율자**: Reader/Writer 제공.  
- **Engine은 단일 진입점**: Store와 도메인 서비스 감쌈.  
- **도메인 서비스는 순수**: 독립적이며 교체 가능.  
- **구독은 세밀하게**: 필요 최소 단위로.  
- 이 구조는 **확장성, 유지보수성, 안정성**을 갖춘 복잡한 에디터/앱에 적합합니다.
