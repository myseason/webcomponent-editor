1) 현재 구조 – 무엇이 있는가
    •   전역 상태 (Zustand)
    •   editStore.ts에 프로젝트/페이지/노드/UI 슬라이스가 결합된 단일 스토어가 존재합니다. 페이지 추가·삭제/선택, 노드 이동/토글, UI 모드/선택 등 모든 변경은 여기서 일어납니다  ￼.
    •   페이지 조작(addPage/rename/remove/select)은 pageSlice.ts에, 노드 조작(appendChild/move/toggleHidden/Locked)은 nodeSlice.ts에, UI 상태(selectedId, 허브탭 등)는 uiSlice.ts에 구현되어 있습니다  ￼.
    •   엔진 파사드 (EditorEngine)
    •   스토어 접근을 캡슐화하는 얇은 파사드가 이미 존재하며, 셀렉터·명령을 엔진 메서드로 노출합니다(예: getSelectedId, selectNode, moveNode, getChildrenIds 등)  ￼.
    •   여러 UI 컴포넌트는 여전히 useEditor()를 통해 직접 스토어를 읽습니다(상태 접근 산재)  ￼.
    •   컨트롤러(Reader/Writer) 도입 현황
    •   Pages: PagesController + PagesFacadeController로 분리·정리되어 있고, PagesPanel.tsx가 파사드 컨트롤러를 사용합니다(읽기/쓰기 인터페이스로 렌더와 이벤트를 처리)  ￼.
    •   Layers: LayersController가 있고, Layers.tsx가 컨트롤러에서 reader()/writer()를 받아 사용하도록 리팩토링되어 있습니다(선택·보이기/잠금 토글·드래그 앤 드롭)  ￼.
    •   Actions: ActionsController + ActionsFacadeController가 존재하며, ActionsPanel.tsx도 파사드를 사용하도록 정리되어 있습니다(액션 스텝 CRUD/실행)  ￼.
    •   Policy/Binding/UI: ProjectPolicyController, BindingController, UiController가 각각 분리되어 있고, 정책/바인딩/뷰 모드·허브 탭 등 UI 상태를 담당합니다  ￼.
    •   타입·레지스트리
    •   컴포넌트 정의/노드/페이지/액션 등의 코어 타입은 core/types.ts에 집중되어 있고, 런타임 액션 스텝 타입은 runtime/actions.ts로 분리되어 있습니다(액션 스텝은 여기를 단일 소스로 삼는 게 안전)  ￼.
    •   컴포넌트 정의 조회(getDefinition)는 core/registry.ts를 통해 이뤄집니다(레이어·인스펙터에서 사용)  ￼.

요약 진단
    •   컨트롤러(Reader/Writer) 방향으로 좌/하 패널 일부가 이미 이행되었습니다(페이지, 레이어, 액션).
    •   하지만 여전히 많은 컴포넌트가 useEditor()로 직접 상태를 읽는 혼합 상태입니다(오래된 접근 잔존)  ￼.
    •   타입 소스가 이원화된 부분(액션 스텝 등)은 **단일 권위(Single Source of Truth)**로 통일 필요  ￼.

⸻

2) 목표 아키텍처(재확인)
    •   헥사고날
    •   도메인(Core): Project/Pages/Nodes/Styles/Binding/Policy/Actions(타입·규칙)
    •   애플리케이션: EditorEngine(스토어 파사드: 읽기/쓰기, 토큰/구독 제공)
    •   어댑터(Ports/Controllers): 각 도메인별 XxxController(Reader/Writer). 필요 시 복수 컨트롤러를 단일 뷰에 묶는 XxxFacadeController.
    •   UI(View): React 컴포넌트. 컨트롤러 외에는 스토어/엔진 직접 참조 금지.

현재 리포지토리는 이 목표에 부합하는 스켈레톤이 이미 존재하고(특히 Pages/Layers/Actions), 나머지 화면으로의 확산이 과제입니다.  ￼

⸻

3) 적용 계획 (상세 로드맵)

3.1 공통 기반 정비 (선행 작업)
    1.  타입 단일화
    •   액션 스텝 타입 참조를 runtime/actions.ts로 통일(컨트롤러 및 패널) → 중복/충돌 제거  ￼.
    2.  EditorEngine 확정
    •   현 EditorEngine 파사드 메서드를 도메인별 네임스페이스로 정리(예: pages.*, nodes.*, ui.*, policy.*, binding.*), 이미 구현된 메서드 시그니처를 문서화하고 추가 토큰 제공자(예: uiToken, nodesToken, pagesToken)를 일관 네이밍으로 통일  ￼.
    3.  컨트롤러 컨벤션 확정
    •   모든 컨트롤러는 (engine: EditorEngine) => ({ reader(): Reader; writer(): Writer })
    •   Reader: 순수 조회 + 토큰/구독 키만 노출, Writer: 커맨드만(undo/redo 대상)
    •   파사드 컨트롤러는 2개 이상 도메인이 필요한 화면에만 한정(Pages/Ui, Actions/Binding/Ui 등).

3.2 화면 단위 확산 계획
    •   이미 완료/진행 중
    •   PagesPanel → PagesFacadeController 사용 (OK)  ￼
    •   Layers → LayersController 사용 (OK, DnD 룰/컨테이너 판정 포함)  ￼
    •   ActionsPanel → ActionsFacadeController 사용 (OK, 실행/CRUD)  ￼
    •   다음 적용 대상 (우선 순위)
    1.  Right/Inspector 계열
    •   Inspector.tsx/StylesSection.tsx/PropsAutoSection.tsx/SchemaEditor.tsx → 각각 InspectorController/BindingController/PolicyController로 읽기·쓰기 라우팅. useEditor 잔존 제거. (현재 일부 잔존)  ￼
    2.  Left/Assets·Components·ProjectStylesheets
    •   자산/컴포넌트/스타일시트 패널 → Project/Assets/Styles 도메인 컨트롤러 신설 또는 분리.
    3.  Bottom/Data/Flows/Fragments
    •   DataPanel → BindingController 중심, Flows/Fragments → 필요 시 별도 도메인 컨트롤러.
    •   각 화면 적용 체크리스트
    •   (A) useEditor 제거 → 대응 컨트롤러의 reader()/writer() 사용
    •   (B) 상태 구독: useControllerTick(() => reader.tokenX()) 혹은 reader.tokenX()를 deps에 넣어 리렌더 트리거(이미 패널들에서 사용 패턴 확립)  ￼
    •   (C) 이벤트 핸들러는 반드시 Writer 경유(뷰에서 예외/검증 코드는 금지 → 컨트롤러로 이동)
    •   (D) 정책/가드(가시성/권한)는 ProjectPolicyController/Guard로 일원화.

3.3 리스크와 해결 전략
    •   혼용 접근 제거: 컴포넌트 내부에서 useEditor()·editorStore.getState() 접근이 남아 있으면 컨트롤러 규칙을 깨고, 동기화 문제가 발생합니다. 검색 제거 대상으로 전량 치환(이미 Actions/Layers/Pages에서 선례)  ￼.
    •   토큰 설계: 리렌더 트리거 키가 컨트롤러마다 제각각이면 렌더 불일치가 생깁니다. nodesToken/pagesToken/uiToken/policyToken/bindingToken 명명 통일로 해결(현재 일부 컨트롤러에서 사용 중) .
    •   액션 타입 중복: 컨트롤러 내부에서 독자 타입을 정의하면 패널과 충돌합니다. runtime/actions.ts로 통일(컨트롤러·패널 모두 이 파일만 import)  ￼.

⸻

4) 파일별 적용 우선순위/작업 보드

아래는 현 소스의 의존도와 변경 난이도를 기준으로 한 실제 작업 순서입니다.
    1.  Right 패널군
    •   editor/rightPanel/Inspector.tsx → InspectorController로 완전 전환(현재 일부 잔존 가능)  ￼
    •   StylesSection.tsx, PropsAutoSection.tsx, SchemaEditor.tsx → 각각 BindingController/ProjectPolicyController에 독립 위임(데이터 바인딩/정책 가시성/스키마 편집)  ￼
    2.  Left 패널군
    •   AssetsPanel.tsx, ComponentsPanel.tsx, ProjectStylesheets.tsx → 도메인 컨트롤러 신설(Assets/Components/Styles). 기존 레지스트리/스타일 정책(globalStylePolicy.ts) 사용부는 컨트롤러로 우회  ￼.
    3.  Bottom 패널군
    •   DataPanel.tsx → BindingController 중심(경로 자동완성/검증 포함)  ￼
    •   FlowsPanel.tsx/FragmentsPanel.tsx → 필요 도메인 컨트롤러 정의(플로우/프래그먼트 모델 확인 후 적용).
    4.  중복 타입/유틸 정리
    •   액션 스텝/정의: runtime/actions.ts 단일화, 컨트롤러와 패널에서 모두 이 파일 import  ￼.
    •   컴포넌트 정의 조회: 항상 core/registry.ts 사용(직접 정의 접근 금지)  ￼.

⸻

5) 운영 규칙(재확인)
    •   View는 오직 컨트롤러만 사용(스토어/엔진 직참 금지).
    •   Reader는 조회와 토큰만, Writer는 커맨드만.
    •   복수 도메인 필요한 화면만 파사드 컨트롤러(Pages+Ui, Actions+Binding+Ui).
    •   타입/정책은 단일 소스로(예: 액션 스텝은 runtime/actions.ts)  ￼.

⸻

6) 바로 실행 가능한 “다음 액션”
    1.  Right/Inspector 계열 전환 배치
    •   Inspector.tsx에서 남은 useEditor 참조 제거 → InspectorController의 reader()/writer()만 사용하도록 교체.
    •   StylesSection/PropsAutoSection/SchemaEditor에서 바인딩/정책 접근을 각각 BindingController/ProjectPolicyController로 이관(핸들러만 교체, UI 불변)  ￼.
    2.  토큰 네이밍 통일 PR
    •   EditorEngine과 각 컨트롤러의 토큰 메서드 명을 *Token() 계열로 통일(uiToken, nodesToken, pagesToken, policyToken, bindingToken)하고 문서화  ￼.
    3.  액션 타입 단일화 PR
    •   컨트롤러/패널에서 runtime/actions.ts만 import 하도록 일괄 치환(기존 충돌 이슈 예방) 